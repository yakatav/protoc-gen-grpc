<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Google.Protobuf.Reflection" #>
//Generated by Grpc CodeGenerator for Unreal, do not edit!
#include "<#=s.TurboLinkBasicFileName#>Service.h"
#include "<#=s.TurboLinkBasicFileName#>Client.h"
#include "<#=s.CamelFileName#>Service_Private.h"
#include "<#=s.CamelFileName#>Marshaling.h"
<#
foreach(String dependency in s.DependencyFiles)
{
#>
#include "<#=dependency#>Marshaling.h"
<#
}
#>
#include "TurboLinkGrpcManager_Private.h"
#include "TurboLinkGrpcUtilities.h"
<#
foreach(GrpcService service in s.ServiceArray)
{
#>

U<#=service.Name#>::U<#=service.Name#>()
	: d(new U<#=service.Name#>::Private())
{
}

U<#=service.Name#>::~U<#=service.Name#>()
{
	delete d;
}

void U<#=service.Name#>::Connect()
{
	FString serviceEndPoint = UTurboLinkGrpcUtilities::GetTurboLinkGrpcConfig()->GetServiceEndPoint(TEXT("<#=service.Name#>"));
	UE_LOG(LogTurboLink, Warning, TEXT("Connect to <#=service.Name#>: '%s'"), *serviceEndPoint);

	if (d->Channel == nullptr) {
		d->Channel = TurboLinkManager->d->CreateServiceChannel((const char*)StringCast<UTF8CHAR>(*serviceEndPoint).Get(), this);
	}
	if (d->Stub == nullptr) {
		d->Stub = <#=s.GrpcPackageName#>::<#=service.Name#>::NewStub(d->Channel->RpcChannel);
	}

	grpc_connectivity_state currentChannelState = d->Channel->RpcChannel->GetState(true);
	if (OnServiceStateChanged.IsBound())
	{
		OnServiceStateChanged.Broadcast(UTurboLinkGrpcManager::Private::GrpcStateToServiceState(currentChannelState));
	}
}

EGrpcServiceState U<#=service.Name#>::GetServiceState() const
{
	if (d->Channel == nullptr) return EGrpcServiceState::NotCreate;

	auto rpcChannelState = d->Channel->RpcChannel->GetState(false);
	return UTurboLinkGrpcManager::Private::GrpcStateToServiceState(rpcChannelState);
}

U<#=service.Name#>Client* U<#=service.Name#>::MakeClient()
{
	auto client = UGrpcService::MakeClient<U<#=service.Name#>Client>();
	return client;
}

void U<#=service.Name#>::Shutdown()
{
	Super::Shutdown();
	d->Stub = nullptr;
	if (d->Channel != nullptr) {
		TurboLinkManager->d->RemoveServiceChannel(d->Channel, this);
		d->Channel = nullptr;
	}
}
<#
	foreach (GrpcServiceMethod method in service.MethodArray)
	{
		if(!method.ClientStreaming) {
#>

<# if(method.ServerStreaming) { #>
void U<#=service.Name#>::Call<#=method.Name#>(const <#=method.InputType#>& Request, F<#=method.Name#>ResponseLambda ResponseLambda, F<#=method.Name#>FinishLambda FinishLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
<# } else {#>
void U<#=service.Name#>::Call<#=method.Name#>(const <#=method.InputType#>& Request, F<#=method.Name#>ResponseLambda ResponseLambda, FGrpcMetaData MetaData, float DeadLineSeconds)
<#}#>
{
	if (InnerClient == nullptr)
	{
		InnerClient = MakeClient();
	}
	U<#=service.Name#><#=method.Name#>LambdaWrapper* lambdaWrapper = NewObject<U<#=service.Name#><#=method.Name#>LambdaWrapper>();
	lambdaWrapper->InnerClient = InnerClient;
	lambdaWrapper->ResponseLambda = ResponseLambda;
<# if(method.ServerStreaming) { #>
	lambdaWrapper->FinishLambda = FinishLambda;
<#}#>
	lambdaWrapper->Handle = InnerClient->Init<#=method.Name#>();
	InnerClient->On<#=method.Name#>Response.AddUniqueDynamic(lambdaWrapper, &U<#=service.Name#><#=method.Name#>LambdaWrapper::OnResponse);
<#
			if(method.ServerStreaming) {
#>
	InnerClient->OnContextStateChange.AddUniqueDynamic(lambdaWrapper, &U<#=service.Name#><#=method.Name#>LambdaWrapper::OnContextStateChanged);
<#
			}
#>
	InnerClient-><#=method.Name#>(lambdaWrapper->Handle, Request, MetaData, DeadLineSeconds);
}
<#
		}
	}
#>
<#
}
#>
